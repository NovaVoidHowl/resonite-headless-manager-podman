<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Resonite Headless Manager API</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background-color: #fafafa;
            color: #3b4151;
            line-height: 1.5;
        }

        .header {
            background: linear-gradient(90deg, #1f8954 0%, #17a2b8 100%);
            color: white;
            padding: 2rem 0;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            font-weight: 300;
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        .info-section {
            background: white;
            border-radius: 8px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .info-section h2 {
            color: #1f8954;
            margin-bottom: 1rem;
            font-size: 1.8rem;
        }

        .info-section p {
            margin-bottom: 1rem;
            color: #666;
        }

        .endpoint-group {
            background: white;
            border-radius: 8px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .group-header {
            background: #f8f9fa;
            padding: 1.5rem 2rem;
            border-bottom: 1px solid #e9ecef;
        }

        .group-header h3 {
            color: #495057;
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
        }

        .group-header p {
            color: #6c757d;
            margin: 0;
        }

        .endpoint {
            border-bottom: 1px solid #e9ecef;
        }

        .endpoint:last-child {
            border-bottom: none;
        }        .endpoint-header {
            padding: 1.5rem 2rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 1rem;
            transition: background-color 0.2s;
            width: 100%;
            border: none;
            background: none;
            text-align: left;
            font-family: inherit;
            font-size: inherit;
        }

        .endpoint-header:hover,
        .endpoint-header:focus {
            background-color: #f8f9fa;
            outline: 2px solid #1f8954;
            outline-offset: -2px;
        }

        .method {
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            font-weight: 600;
            font-size: 0.875rem;
            min-width: 80px;
            text-align: center;
            text-transform: uppercase;
        }

        .method.get {
            background-color: #d1ecf1;
            color: #0c5460;
        }

        .method.post {
            background-color: #d4edda;
            color: #155724;
        }

        .method.websocket {
            background-color: #fff3cd;
            color: #856404;
        }

        .endpoint-path {
            font-family: 'Courier New', monospace;
            font-weight: 500;
            font-size: 1.1rem;
            flex-grow: 1;
        }

        .endpoint-summary {
            color: #6c757d;
            font-size: 0.9rem;
        }

        .endpoint-details {
            display: none;
            padding: 0 2rem 2rem 2rem;
        }

        .endpoint.expanded .endpoint-details {
            display: block;
        }

        .endpoint-details h4 {
            color: #495057;
            margin-bottom: 1rem;
            font-size: 1.2rem;
        }

        .endpoint-details p {
            margin-bottom: 1rem;
            color: #666;
        }

        .code-block {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 1rem;
            margin: 1rem 0;
            font-family: 'Courier New', monospace;
            font-size: 0.875rem;
            overflow-x: auto;
        }

        .parameters {
            margin: 1rem 0;
        }

        .parameter {
            background: #f8f9fa;
            border-left: 4px solid #17a2b8;
            padding: 1rem;
            margin-bottom: 0.5rem;
        }

        .parameter-name {
            font-weight: 600;
            color: #495057;
        }

        .parameter-type {
            color: #6c757d;
            font-style: italic;
            margin-left: 0.5rem;
        }

        .parameter-description {
            margin-top: 0.5rem;
            color: #666;
        }

        .responses {
            margin: 1rem 0;
        }

        .response {
            background: #f8f9fa;
            border-left: 4px solid #28a745;
            padding: 1rem;
            margin-bottom: 0.5rem;
        }

        .response-code {
            font-weight: 600;
            color: #28a745;
        }

        .response-description {
            margin-top: 0.5rem;
            color: #666;
        }

        .toggle-icon {
            margin-left: auto;
            transition: transform 0.2s;
        }

        .endpoint.expanded .toggle-icon {
            transform: rotate(180deg);
        }

        .websocket-info {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 4px;
            padding: 1rem;
            margin: 1rem 0;
        }

        .websocket-info h5 {
            color: #856404;
            margin-bottom: 0.5rem;
        }

        .websocket-info p {
            color: #856404;
            margin: 0;
        }

        .try-it-section {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 2rem;
            margin-top: 2rem;
        }

        .try-it-section h3 {
            color: #495057;
            margin-bottom: 1rem;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #495057;
        }

        .form-group input,
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 1rem;
        }

        .btn {
            background: #1f8954;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.2s;
        }

        .btn:hover {
            background: #198754;
        }

        .response-output {
            background: #212529;
            color: #f8f9fa;
            padding: 1rem;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.875rem;
            margin-top: 1rem;
            min-height: 100px;
            white-space: pre-wrap;
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }

            .endpoint-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem;
            }

            .endpoint-path {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Resonite Headless Manager API</h1>
        <p>WebSocket and REST API for managing Resonite headless servers</p>
    </div>

    <div class="container">
        <div class="info-section">
            <h2>API Information</h2>
            <p><strong>Base URL:</strong> <code>http://your-server-ip:8000</code></p>
            <p><strong>WebSocket URL:</strong> <code>ws://your-server-ip:8000</code></p>
            <p>This API provides comprehensive management capabilities for Resonite headless servers including real-time monitoring, configuration management, and world control.</p>
        </div>

        <!-- WebSocket Endpoints -->
        <div class="endpoint-group">
            <div class="group-header">
                <h3>WebSocket Endpoints</h3>
                <p>Real-time communication endpoints for monitoring and control</p>
            </div>

            <div class="endpoint">
                <button type="button" class="endpoint-header" onclick="toggleEndpoint(this.parentElement)" onkeydown="if(event.key==='Enter'||event.key===' '){toggleEndpoint(this.parentElement);}">
                    <span class="method websocket">WS</span>
                    <span class="endpoint-path">/ws/command</span>
                    <span class="endpoint-summary">Send commands to the server</span>
                    <span class="toggle-icon">â–¼</span>
                </button>
                <div class="endpoint-details">
                    <h4>Description</h4>
                    <p>Send commands to the headless server and receive structured responses.</p>

                    <h4>Message Format</h4>
                    <div class="code-block">{
  "type": "command",
  "command": "command_string"
}</div>

                    <h4>Special Commands</h4>
                    <div class="parameters">
                        <div class="parameter">
                            <span class="parameter-name">listbans</span>
                            <div class="parameter-description">Returns a structured list of banned users</div>
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">friendRequests</span>
                            <div class="parameter-description">Returns a list of pending friend requests</div>
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">status</span>
                            <div class="parameter-description">Returns current server status</div>
                        </div>
                        <div class="parameter">
                            <span class="parameter-name">users</span>
                            <div class="parameter-description">Returns list of users</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="endpoint">
                <button type="button" class="endpoint-header" onclick="toggleEndpoint(this.parentElement)" onkeydown="if(event.key==='Enter'||event.key===' '){toggleEndpoint(this.parentElement);}">
                    <span class="method websocket">WS</span>
                    <span class="endpoint-path">/ws/worlds</span>
                    <span class="endpoint-summary">Monitor world information</span>
                    <span class="toggle-icon">â–¼</span>
                </button>
                <div class="endpoint-details">
                    <h4>Description</h4>
                    <p>Real-time updates about world status, users, and properties.</p>

                    <h4>Request Message</h4>
                    <div class="code-block">{
                      "type": "get_worlds"
                    }</div>

                    <h4>Response Example</h4>
                    <div class="code-block">{
  "type": "worlds_update",
  "output": [
    {
      "name": "World Name",
      "sessionId": "S-xxx",
      "users": 2,
      "present": 2,
      "maxUsers": 10,
      "uptime": "2 hours 30 minutes",
      "accessLevel": "Anyone",
      "hidden": false,
      "mobileFriendly": true,
      "description": "World description",
      "tags": "tag1,tag2",
      "users_list": [
        {
          "username": "User1",
          "id": "U-xxx",
          "role": "User",
          "present": true,
          "ping": 50,
          "fps": 72.5,
          "silenced": false
        }
      ]
    }
  ],
  "timestamp": "2025-05-31T12:34:56.789Z"
}</div>
                </div>
            </div>

            <div class="endpoint">
                <button type="button" class="endpoint-header" onclick="toggleEndpoint(this.parentElement)" onkeydown="if(event.key==='Enter'||event.key===' '){toggleEndpoint(this.parentElement);}">
                    <span class="method websocket">WS</span>
                    <span class="endpoint-path">/ws/logs</span>
                    <span class="endpoint-summary">Stream container logs</span>
                    <span class="toggle-icon">â–¼</span>
                </button>
                <div class="endpoint-details">
                    <h4>Description</h4>
                    <p>Real-time streaming of container logs. Automatically sends recent logs on connection and streams new logs.</p>

                    <div class="websocket-info">
                        <h5>Auto-streaming</h5>
                        <p>This endpoint automatically streams log updates. No request message needed.</p>
                    </div>

                    <h4>Response Example</h4>
                    <div class="code-block">{
  "type": "container_output",
  "output": "Server log message",
  "timestamp": "2025-05-31T12:34:56.789Z"
}</div>
                </div>
            </div>            <div class="endpoint">
                <button type="button" class="endpoint-header" onclick="toggleEndpoint(this.parentElement)" onkeydown="if(event.key==='Enter'||event.key===' '){toggleEndpoint(this.parentElement);}">
                    <span class="method websocket">WS</span>
                    <span class="endpoint-path">/ws/cpu</span>
                    <span class="endpoint-summary">Monitor CPU usage</span>
                    <span class="toggle-icon">â–¼</span>
                </button>
                <div class="endpoint-details">
                    <h4>Description</h4>
                    <p>Real-time CPU usage monitoring with updates every second.</p>

                    <div class="websocket-info">
                        <h5>Auto-streaming</h5>
                        <p>This endpoint automatically streams CPU usage updates every second.</p>
                    </div>

                    <h4>Response Example</h4>
                    <div class="code-block">{
  "type": "cpu_update",
  "cpu_usage": 5.2
}</div>
                </div>
            </div>            <div class="endpoint">
                <button type="button" class="endpoint-header" onclick="toggleEndpoint(this.parentElement)" onkeydown="if(event.key==='Enter'||event.key===' '){toggleEndpoint(this.parentElement);}">
                    <span class="method websocket">WS</span>
                    <span class="endpoint-path">/ws/memory</span>
                    <span class="endpoint-summary">Monitor memory usage</span>
                    <span class="toggle-icon">â–¼</span>
                </button>
                <div class="endpoint-details">
                    <h4>Description</h4>
                    <p>Real-time memory usage monitoring with updates every second.</p>

                    <div class="websocket-info">
                        <h5>Auto-streaming</h5>
                        <p>This endpoint automatically streams memory usage updates every second.</p>
                    </div>

                    <h4>Response Example</h4>
                    <div class="code-block">{
  "type": "memory_update",
  "memory_percent": 45.3,
  "memory_used": "4.2GB",
  "memory_total": "16.0GB"
}</div>
                </div>
            </div>            <div class="endpoint">
                <button type="button" class="endpoint-header" onclick="toggleEndpoint(this.parentElement)" onkeydown="if(event.key==='Enter'||event.key===' '){toggleEndpoint(this.parentElement);}">
                    <span class="method websocket">WS</span>
                    <span class="endpoint-path">/ws/container_status</span>
                    <span class="endpoint-summary">Monitor container status</span>
                    <span class="toggle-icon">â–¼</span>
                </button>
                <div class="endpoint-details">
                    <h4>Description</h4>
                    <p>Get container status information on demand.</p>

                    <h4>Request Message</h4>
                    <div class="code-block">{
  "type": "get_container_status"
}</div>

                    <h4>Response Example</h4>
                    <div class="code-block">{
  "type": "container_status_update",
  "status": {
    "status": "running",
    "name": "container_name",
    "id": "container_id",
    "image": "container_image"
  }
}</div>
                </div>
            </div>            <div class="endpoint">
                <button type="button" class="endpoint-header" onclick="toggleEndpoint(this.parentElement)" onkeydown="if(event.key==='Enter'||event.key===' '){toggleEndpoint(this.parentElement);}">
                    <span class="method websocket">WS</span>
                    <span class="endpoint-path">/ws/heartbeat</span>
                    <span class="endpoint-summary">Heartbeat connection</span>
                    <span class="toggle-icon">â–¼</span>
                </button>
                <div class="endpoint-details">
                    <h4>Description</h4>
                    <p>Heartbeat connection to keep other WebSocket connections alive.</p>

                    <div class="websocket-info">
                        <h5>Connection maintenance</h5>
                        <p>This endpoint is used internally to maintain connection state.</p>
                    </div>
                </div>
            </div>            <div class="endpoint">
                <button type="button" class="endpoint-header" onclick="toggleEndpoint(this.parentElement)" onkeydown="if(event.key==='Enter'||event.key===' '){toggleEndpoint(this.parentElement);}">
                    <span class="method websocket">WS</span>
                    <span class="endpoint-path">/ws/status</span>
                    <span class="endpoint-summary">Status monitoring and updates</span>
                    <span class="toggle-icon">â–¼</span>
                </button>
                <div class="endpoint-details">
                    <h4>Description</h4>
                    <p>Monitor server status and receive real-time updates.</p>

                    <h4>Request Message</h4>
                    <div class="code-block">{
  "type": "get_status"
}</div>
                </div>
            </div>
        </div>        <!-- REST API Endpoints (Dynamically Loaded) -->
        <div class="endpoint-group" id="rest-endpoints">
            <div class="group-header">
                <h3>REST API Endpoints</h3>
                <p>HTTP endpoints for configuration and container management (loaded from OpenAPI)</p>
            </div>            <div class="loading-indicator" style="padding: 2rem; text-align: center; color: #666;">
                Loading REST endpoints from OpenAPI schema...
            </div>
        </div>

        <!-- Dynamic REST endpoints will be inserted here -->
        </div>

        <!-- Try It Out Section -->
        <div class="try-it-section">
            <h3>Try It Out</h3>
            <p>Test the API endpoints directly from this interface.</p>
              <div class="form-group">
                <label for="endpoint-select">Select Endpoint:</label>
                <select id="endpoint-select" onchange="updateTryItForm()">
                    <option value="">Select an endpoint...</option>
                    <!-- Options will be dynamically populated from OpenAPI schema -->
                </select>
            </div>
              <div class="form-group" id="request-body-group" style="display: none;">
                <label for="request-body">Request Body (JSON):</label>
                <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
                    <button type="button" class="btn" id="refresh-config-btn" onclick="refreshCurrentConfig()" style="font-size: 0.875rem; padding: 0.5rem 1rem; display: none;">
                        ðŸ”„ Refresh Current Config
                    </button>
                </div>
                <textarea id="request-body" rows="6" placeholder="Enter JSON request body..."></textarea>
            </div>

            <button class="btn" onclick="makeRequest()">Send Request</button>

            <div class="response-output" id="response-output">Response will appear here...</div>
        </div>

        <!-- WebSocket Testing Section -->
        <div class="try-it-section">
            <h3>WebSocket Testing</h3>
            <p>Test WebSocket connections and send messages.</p>

            <div class="form-group">
                <label for="ws-endpoint">WebSocket Endpoint:</label>
                <select id="ws-endpoint">
                    <option value="/ws/command">Command</option>
                    <option value="/ws/worlds">Worlds</option>
                    <option value="/ws/logs">Logs</option>
                    <option value="/ws/cpu">CPU</option>
                    <option value="/ws/memory">Memory</option>
                    <option value="/ws/container_status">Container Status</option>
                    <option value="/ws/status">Status</option>
                </select>
            </div>

            <div class="form-group">
                <label for="ws-message">Message (JSON):</label>
                <textarea id="ws-message" rows="4" placeholder='{"type": "command", "command": "status"}'></textarea>
            </div>

            <button class="btn" onclick="connectWebSocket()" id="ws-connect-btn">Connect</button>
            <button class="btn" onclick="sendWebSocketMessage()" id="ws-send-btn" disabled>Send Message</button>
            <button class="btn" onclick="disconnectWebSocket()" id="ws-disconnect-btn" disabled>Disconnect</button>

            <div class="response-output" id="ws-output">WebSocket messages will appear here...</div>
        </div>
    </div>    <script>
        let currentWebSocket = null;
        let openApiSchema = null;

        // Load OpenAPI schema and populate REST endpoints
        async function loadOpenApiEndpoints() {
            try {
                const response = await fetch('/openapi.json');
                openApiSchema = await response.json();

                const restEndpointsContainer = document.getElementById('rest-endpoints');
                const loadingIndicator = restEndpointsContainer.querySelector('.loading-indicator');

                // Remove loading indicator
                loadingIndicator.remove();

                // Group endpoints by tags
                const endpointsByTag = {};

                Object.entries(openApiSchema.paths).forEach(([path, methods]) => {
                    Object.entries(methods).forEach(([method, spec]) => {
                        if (spec.tags && spec.tags.length > 0) {
                            const tag = spec.tags[0];
                            if (!endpointsByTag[tag]) {
                                endpointsByTag[tag] = [];
                            }
                            endpointsByTag[tag].push({
                                path,
                                method: method.toUpperCase(),
                                spec
                            });
                        }
                    });
                });

                // Render endpoint groups
                Object.entries(endpointsByTag).forEach(([tag, endpoints]) => {
                    const groupDiv = document.createElement('div');
                    groupDiv.className = 'endpoint-group';

                    groupDiv.innerHTML = `
                        <div class="group-header">
                            <h3>${tag}</h3>
                            <p>${getTagDescription(tag)}</p>
                        </div>
                    `;

                    endpoints.forEach(endpoint => {
                        const endpointDiv = document.createElement('div');
                        endpointDiv.className = 'endpoint';
                        endpointDiv.innerHTML = createEndpointHtml(endpoint);
                        groupDiv.appendChild(endpointDiv);
                    });

                    restEndpointsContainer.appendChild(groupDiv);
                });

                // Populate the try-it-out dropdown
                populateEndpointSelector(endpointsByTag);

            } catch (error) {
                console.error('Failed to load OpenAPI schema:', error);
                const restEndpointsContainer = document.getElementById('rest-endpoints');
                const loadingIndicator = restEndpointsContainer.querySelector('.loading-indicator');
                loadingIndicator.innerHTML = `
                    <p style="color: #dc3545;">
                        Failed to load REST endpoints from OpenAPI schema.
                        Error: ${error.message}
                    </p>
                `;
            }
        }

        function getTagDescription(tag) {
          const descriptions = {
            'Headless Instance Configuration': 'Endpoints for managing headless server configuration',
            'Container Control': 'Endpoints for managing containers',
            'Manager App Configuration': 'Endpoints for managing setup and configuration of the Resonite Headless Manager',
          };
          return descriptions[tag] || 'API endpoints';
        }

        function createEndpointHtml(endpoint) {
            const { path, method, spec } = endpoint;
            const methodClass = method.toLowerCase();

            let responsesHtml = '';
            if (spec.responses) {
                responsesHtml = '<div class="responses">';
                Object.entries(spec.responses).forEach(([code, response]) => {
                    responsesHtml += `
                        <div class="response">
                            <span class="response-code">${code} ${getHttpStatusText(code)}</span>
                            <div class="response-description">${response.description || ''}</div>
                        </div>
                    `;
                });
                responsesHtml += '</div>';
            }

            let requestBodyHtml = '';
            if (method === 'POST' && spec.requestBody) {
                requestBodyHtml = `
                    <h4>Request Body</h4>
                    <div class="code-block">${getRequestBodyExample(spec.requestBody)}</div>
                `;
            }

            return `
                <button type="button" class="endpoint-header" onclick="toggleEndpoint(this.parentElement)" onkeydown="if(event.key==='Enter'||event.key===' '){toggleEndpoint(this.parentElement);}">
                    <span class="method ${methodClass}">${method}</span>
                    <span class="endpoint-path">${path}</span>
                    <span class="endpoint-summary">${spec.summary || ''}</span>
                    <span class="toggle-icon">â–¼</span>
                </button>
                <div class="endpoint-details">
                    <h4>Description</h4>
                    <p>${spec.description || spec.summary || 'No description available'}</p>
                    ${requestBodyHtml}
                    ${responsesHtml}
                </div>
            `;
        }

        function getHttpStatusText(code) {
            const statusTexts = {
                '200': 'OK',
                '400': 'Bad Request',
                '500': 'Internal Server Error'
            };
            return statusTexts[code] || '';
        }

        function getRequestBodyExample(requestBody) {
            // Try to generate a simple example based on the request body schema
            if (requestBody.content && requestBody.content['application/json']) {
                const schema = requestBody.content['application/json'].schema;
                if (schema) {
                    return JSON.stringify(generateExampleFromSchema(schema), null, 2);
                }
            }
            return '{\n  "example": "request body"\n}';
        }

        function generateExampleFromSchema(schema) {
            if (schema.type === 'object' && schema.properties) {
                const example = {};
                Object.entries(schema.properties).forEach(([key, prop]) => {
                    if (prop.type === 'string') {
                        example[key] = `example_${key}`;
                    } else if (prop.type === 'number') {
                        example[key] = 123;
                    } else if (prop.type === 'boolean') {
                        example[key] = true;
                    } else {
                        example[key] = 'example_value';
                    }
                });
                return example;
            }
            return { example: 'data' };
        }

        function populateEndpointSelector(endpointsByTag) {
            const select = document.getElementById('endpoint-select');

            // Clear existing options except the first one
            while (select.children.length > 1) {
                select.removeChild(select.lastChild);
            }

            Object.entries(endpointsByTag).forEach(([tag, endpoints]) => {
                endpoints.forEach(endpoint => {
                    const option = document.createElement('option');
                    option.value = `${endpoint.method}:${endpoint.path}`;
                    option.textContent = `${endpoint.method} ${endpoint.path}`;
                    select.appendChild(option);
                });
            });
        }

        // Load endpoints when page loads
        document.addEventListener('DOMContentLoaded', loadOpenApiEndpoints);

        function toggleEndpoint(element) {
            element.classList.toggle('expanded');
        }        function updateTryItForm() {
            const select = document.getElementById('endpoint-select');
            const requestBodyGroup = document.getElementById('request-body-group');
            const requestBody = document.getElementById('request-body');
            const refreshConfigBtn = document.getElementById('refresh-config-btn');

            if (select.value.startsWith('POST:')) {
                requestBodyGroup.style.display = 'block';

                // Get the path from the selected value
                const [method, path] = select.value.split(':');

                // Special handling for POST /api/headless/config - fetch current config
                if (path === '/api/headless/config') {
                    refreshConfigBtn.style.display = 'inline-block';
                    fetchCurrentConfig(requestBody);
                } else {
                    refreshConfigBtn.style.display = 'none';
                    // Try to get request body example from OpenAPI schema
                    if (openApiSchema && openApiSchema.paths[path] && openApiSchema.paths[path].post) {
                        const spec = openApiSchema.paths[path].post;
                        if (spec.requestBody) {
                            requestBody.value = getRequestBodyExample(spec.requestBody);
                        } else {
                            requestBody.value = generateDefaultRequestBody(path);
                        }
                    } else {
                        requestBody.value = generateDefaultRequestBody(path);
                    }
                }
            } else {
                requestBodyGroup.style.display = 'none';
                refreshConfigBtn.style.display = 'none';
                requestBody.value = '';
            }        }

        function refreshCurrentConfig() {
            const requestBody = document.getElementById('request-body');
            fetchCurrentConfig(requestBody);
        }

        async function fetchCurrentConfig(requestBodyElement) {
            try {
                // Show loading message
                requestBodyElement.value = 'Loading current config...';

                // Fetch current config from GET endpoint
                const response = await fetch(window.location.origin + '/api/headless/config');

                if (response.ok) {
                    const currentConfig = await response.text();
                    const formattedConfig = formatJsonResponse(currentConfig);
                    requestBodyElement.value = formattedConfig;
                } else {
                    // If GET fails, fall back to default request body
                    requestBodyElement.value = generateDefaultRequestBody('/api/headless/config');
                }
            } catch (error) {
                console.error('Failed to fetch current config:', error);
                // Fall back to default request body on error
                requestBodyElement.value = generateDefaultRequestBody('/api/headless/config');
            }
        }        function generateDefaultRequestBody(path) {
            // Generate default request bodies for known endpoints
            if (path === '/api/world-properties') {
                return JSON.stringify({
                    sessionId: "S-xxx",
                    properties: {
                        name: "New World Name",
                        description: "Updated description",
                        maxUsers: 20
                    }
                }, null, 2);
            } else if (path === '/api/headless/config') {
                return JSON.stringify({
                    "example": "config data",
                    "note": "Failed to load current config. Please edit with actual configuration."
                }, null, 2);
            } else if (path === '/config') {
                return JSON.stringify({
                    configProperty: "value",
                    anotherProperty: "anotherValue"
                }, null, 2);
            }
            return '{}';
        }function formatJsonResponse(text) {
            try {
                const parsed = JSON.parse(text);
                return JSON.stringify(parsed, null, 2);
            } catch (e) {
                // If it's not valid JSON, return as-is
                return text;
            }
        }

        async function makeRequest() {
            const select = document.getElementById('endpoint-select');
            const requestBody = document.getElementById('request-body');
            const output = document.getElementById('response-output');

            if (!select.value) {
                output.textContent = 'Please select an endpoint';
                return;
            }

            const [method, path] = select.value.split(':');
            const url = window.location.origin + path;

            output.textContent = 'Sending request...';

            try {
                const options = {
                    method: method,
                    headers: {
                        'Content-Type': 'application/json',
                    },
                };

                if (method === 'POST' && requestBody.value.trim()) {
                    options.body = requestBody.value;
                }

                const response = await fetch(url, options);
                const data = await response.text();
                const formattedData = formatJsonResponse(data);

                output.textContent = `Status: ${response.status}\n\n${formattedData}`;
            } catch (error) {
                output.textContent = `Error: ${error.message}`;
            }
        }

        function connectWebSocket() {
            const endpointSelect = document.getElementById('ws-endpoint');
            const output = document.getElementById('ws-output');
            const connectBtn = document.getElementById('ws-connect-btn');
            const sendBtn = document.getElementById('ws-send-btn');
            const disconnectBtn = document.getElementById('ws-disconnect-btn');

            if (currentWebSocket) {
                output.textContent += '\nDisconnecting existing connection...\n';
                currentWebSocket.close();
            }

            const wsUrl = `ws://${window.location.host}${endpointSelect.value}`;
            output.textContent = `Connecting to ${wsUrl}...\n`;

            currentWebSocket = new WebSocket(wsUrl);

            currentWebSocket.onopen = function(event) {
                output.textContent += 'Connected!\n';
                connectBtn.disabled = true;
                sendBtn.disabled = false;
                disconnectBtn.disabled = false;
            };
              currentWebSocket.onmessage = function(event) {
                const timestamp = new Date().toLocaleTimeString();
                const formattedData = formatJsonResponse(event.data);
                output.textContent += `[${timestamp}] Received:\n${formattedData}\n\n`;
                output.scrollTop = output.scrollHeight;
            };

            currentWebSocket.onclose = function(event) {
                output.textContent += 'Connection closed\n';
                connectBtn.disabled = false;
                sendBtn.disabled = true;
                disconnectBtn.disabled = true;
                currentWebSocket = null;
            };

            currentWebSocket.onerror = function(error) {
                output.textContent += `Error: ${error}\n`;
            };
        }

        function sendWebSocketMessage() {
            const messageInput = document.getElementById('ws-message');
            const output = document.getElementById('ws-output');

            if (!currentWebSocket || currentWebSocket.readyState !== WebSocket.OPEN) {
                output.textContent += 'WebSocket not connected\n';
                return;
            }

            if (!messageInput.value.trim()) {
                output.textContent += 'Please enter a message\n';
                return;
            }
              try {
                const message = messageInput.value;
                currentWebSocket.send(message);
                const timestamp = new Date().toLocaleTimeString();
                const formattedMessage = formatJsonResponse(message);
                output.textContent += `[${timestamp}] Sent:\n${formattedMessage}\n\n`;
                output.scrollTop = output.scrollHeight;
            } catch (error) {
                output.textContent += `Error sending message: ${error.message}\n`;
            }
        }

        function disconnectWebSocket() {
            if (currentWebSocket) {
                currentWebSocket.close();
            }
        }        // Auto-scroll to bottom for outputs
        document.addEventListener('DOMContentLoaded', function() {
            const outputs = document.querySelectorAll('.response-output');
            outputs.forEach(output => {
                // Use MutationObserver instead of deprecated DOMNodeInserted
                const observer = new MutationObserver(function(mutations) {
                    mutations.forEach(function(mutation) {
                        if (mutation.type === 'childList' || mutation.type === 'characterData') {
                            output.scrollTop = output.scrollHeight;
                        }
                    });
                });

                // Configure observer to watch for text changes and child nodes
                observer.observe(output, {
                    childList: true,
                    subtree: true,
                    characterData: true
                });
            });
        });
    </script>
</body>
</html>
